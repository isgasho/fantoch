use crate::command::Command;
use crate::id::RiflGen;
use crate::kvs::{Key, Value};
use crate::log;
use rand::{distributions::Alphanumeric, Rng};
use serde::{Deserialize, Serialize};
use std::iter;

const BLACK_COLOR: &str = "black";

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub struct Workload {
    /// conflict rate  of this workload
    conflict_rate: usize,
    /// number of commands to be submitted in this workload
    commands_per_client: usize,
    /// size of payload in command (in bytes)
    payload_size: usize,
    /// number of commands already issued in this workload
    command_count: usize,
}

impl Workload {
    pub fn new(
        conflict_rate: usize,
        commands_per_client: usize,
        payload_size: usize,
    ) -> Self {
        // check conflict rate value
        assert!(conflict_rate <= 100);

        Self {
            conflict_rate,
            commands_per_client,
            payload_size,
            command_count: 0,
        }
    }

    /// Returns the conflict rate to be generated by this workload.
    pub fn conflict_rate(&self) -> usize {
        self.conflict_rate
    }

    /// Returns the total number of commands to be generated by this workload.
    pub fn commands_per_client(&self) -> usize {
        self.commands_per_client
    }

    /// Returns the payload size of the commands to be generated by this
    /// workload.
    pub fn payload_size(&self) -> usize {
        self.payload_size
    }

    /// Generate the next command.
    pub fn next_cmd(&mut self, rifl_gen: &mut RiflGen) -> Option<Command> {
        // check if we should generate more commands
        if self.command_count < self.commands_per_client {
            if self.command_count % 1000 == 0 {
                log!(
                    "client {:?}: {} of {}",
                    rifl_gen.source(),
                    self.command_count,
                    self.commands_per_client
                );
            }

            // increment command count
            self.command_count += 1;
            // generate new command
            Some(self.gen_cmd(rifl_gen))
        } else {
            log!("client {:?} is done!", rifl_gen.source());
            None
        }
    }

    /// Returns the number of commands already issued.
    pub fn issued_commands(&self) -> usize {
        self.command_count
    }

    /// Returns a boolean indicating whether the workload has finished, i.e. all
    /// commands have been issued.
    pub fn finished(&self) -> bool {
        self.command_count == self.commands_per_client
    }

    /// Generate a command.
    fn gen_cmd(&mut self, rifl_gen: &mut RiflGen) -> Command {
        // generate rifl, key and value
        let rifl = rifl_gen.next_id();
        let key = self.gen_cmd_key(&rifl_gen);
        // TODO: generate something with a given payload size if outside of
        // simulation
        let value = self.gen_cmd_value();

        // generate put command
        // TODO: make it configurable so that we can generate other commands
        // besides put commands.
        Command::put(rifl, key, value)
    }

    /// Generate a command key based on the conflict rate provided.
    fn gen_cmd_key(&mut self, rifl_gen: &RiflGen) -> Key {
        // check if we should generate a conflict:
        let should_conflict = match self.conflict_rate {
            0 => false,
            100 => true,
            c => rand::thread_rng().gen_range(0, 100) < c,
        };

        if should_conflict {
            // black color to generate a conflict
            BLACK_COLOR.to_owned()
        } else {
            // avoid conflict with unique client key
            rifl_gen.source().to_string()
        }
    }

    /// Generate a command payload with the payload size provided.
    fn gen_cmd_value(&self) -> Value {
        let mut rng = rand::thread_rng();
        iter::repeat(())
            .map(|_| rng.sample(Alphanumeric))
            .take(self.payload_size)
            .collect()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::kvs::KVOp;

    #[test]
    fn gen_cmd_key() {
        // create rilf gen
        let client_id = 1;
        let rifl_gen = RiflGen::new(client_id);

        // total commands
        let total_commands = 100;
        let payload_size = 100;

        // create conflicting workload
        let conflict_rate = 100;
        let mut workload =
            Workload::new(conflict_rate, total_commands, payload_size);
        assert_eq!(workload.gen_cmd_key(&rifl_gen), BLACK_COLOR);

        // create non-conflicting workload
        let conflict_rate = 0;
        let mut workload =
            Workload::new(conflict_rate, total_commands, payload_size);
        assert_eq!(workload.gen_cmd_key(&rifl_gen), String::from("1"));
    }

    #[test]
    fn next_cmd() {
        // create rilf gen
        let client_id = 1;
        let mut rifl_gen = RiflGen::new(client_id);

        // total commands
        let total_commands = 10000;
        let payload_size = 10;

        // create workload
        let conflict_rate = 100;
        let mut workload =
            Workload::new(conflict_rate, total_commands, payload_size);

        // check total and issued commands
        assert_eq!(workload.commands_per_client(), total_commands);
        assert_eq!(workload.issued_commands(), 0);

        // the first `total_commands` commands are `Some`
        for i in 1..=total_commands {
            if let Some(cmd) = workload.next_cmd(&mut rifl_gen) {
                let (key, value) = cmd.into_iter().next().unwrap();
                // since the conflict is 100, the key should be BLACK
                assert_eq!(key, BLACK_COLOR);
                // check that the value size is `payload_size`
                if let KVOp::Put(payload) = value {
                    assert_eq!(payload.len(), payload_size);
                } else {
                    panic!("workload should generate PUT commands");
                }

                // check total and issued commands
                assert_eq!(workload.commands_per_client(), total_commands);
                assert_eq!(workload.issued_commands(), i);
            } else {
                panic!("there should be a next command in this workload");
            }
        }

        // check the workload is finished
        assert!(workload.finished());

        // after this, no more commands are generated
        for _ in 1..=10 {
            assert!(workload.next_cmd(&mut rifl_gen).is_none());
        }

        // check the workload is still finished
        assert!(workload.finished());
    }

    #[test]
    fn conflict_rate() {
        for conflict_rate in vec![1, 2, 10, 50] {
            // create rilf gen
            let client_id = 1;
            let mut rifl_gen = RiflGen::new(client_id);

            // total commands
            let total_commands = 100000;
            let payload_size = 0;

            // create workload
            let mut workload =
                Workload::new(conflict_rate, total_commands, payload_size);

            // count black commands
            let mut black_count = 0;

            while let Some(cmd) = workload.next_cmd(&mut rifl_gen) {
                // get command key and check if it's black
                let (key, _) = cmd.into_iter().next().unwrap();
                if key == BLACK_COLOR {
                    black_count += 1;
                }
            }

            // compute percentage of black commands
            let percentage = (black_count * 100) as f64 / total_commands as f64;
            assert_eq!(percentage.round() as usize, conflict_rate);
        }
    }
}
