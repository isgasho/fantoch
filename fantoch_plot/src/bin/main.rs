use color_eyre::eyre::WrapErr;
use color_eyre::Report;
use fantoch::client::{KeyGen, ShardGen};
use fantoch::planet::{Planet, Region};
use fantoch_exp::Protocol;
use fantoch_plot::{
    ErrorBar, ExperimentData, LatencyMetric, MetricsType, PlotFmt, ResultsDB,
    Search, Style,
};
use std::collections::HashMap;

// folder where all results are stored
const RESULTS_DIR: &str = "../graph_executor_zipf01";
// folder where all plots will be stored
const PLOT_DIR: Option<&str> = Some("plots");

fn main() -> Result<(), Report> {
    // set global style
    fantoch_plot::set_global_style()?;

    partial_replication()?;
    // multi_key()?;
    // single_key()?;
    // show_distance_matrix();
    Ok(())
}

#[allow(dead_code)]
fn partial_replication() -> Result<(), Report> {
    // fixed parameters
    let n = 3;
    let keys_per_shard = 1;
    let mut key_gens = Vec::new();
    let zipf_key_count = 1_000_000;
    key_gens.push(KeyGen::Zipf {
        coefficient: 0.1,
        key_count: zipf_key_count,
    });
    // key_gens.push(KeyGen::ConflictRate { conflict_rate: 0 });
    let payload_size = 0;
    let protocols = vec![Protocol::AtlasLocked];

    let shard_combinations = vec![
        // shard_count, shards_per_command
        (1, 1),
        // (2, 1),
        (2, 2),
        // (3, 1),
        (3, 2),
        // (4, 1),
        (4, 2),
        // (5, 1),
        (5, 2),
        /*
        (2, 2),
        (3, 1),
        (3, 2),
        (5, 1),
        */
    ];

    // load results
    let db = ResultsDB::load(RESULTS_DIR).wrap_err("load results")?;

    let clients_per_region = vec![
        // 1024 / 4,
        // 1024 / 2,
        // 1024,
        // 1024 * 2,
        1024 * 4,
        1024 * 8,
        1024 * 16,
        1024 * 24,
        1024 * 32,
        1024 * 36,
        1024 * 40,
        1024 * 48,
        1024 * 56,
        1024 * 64,
        1024 * 96,
        1024 * 128,
        1024 * 160,
        1024 * 192,
        1024 * 224,
        1024 * 256,
        1024 * 272,
    ];

    for key_gen in key_gens {
        // generate all-combo throughput-latency plot
        for latency_metric in vec![
            LatencyMetric::Average,
            LatencyMetric::Percentile(0.99),
            LatencyMetric::Percentile(0.999),
        ] {
            let path = format!(
                "throughput_latency_n{}_{}{}.pdf",
                n,
                key_gen,
                latency_metric.to_file_suffix(),
            );
            // create searches
            let searches = shard_combinations
                .clone()
                .into_iter()
                .flat_map(|(shard_count, shards_per_command)| {
                    let shard_gen = ShardGen::Random { shard_count };
                    protocol_combinations(n, protocols.clone()).into_iter().map(
                        move |(protocol, f)| {
                            let mut search = Search::new(n, f, protocol);
                            search
                                .shards_per_command(shards_per_command)
                                .shard_gen(shard_gen)
                                .keys_per_shard(keys_per_shard)
                                .key_gen(key_gen)
                                .payload_size(payload_size);
                            search
                        },
                    )
                })
                .collect();

            let style_fun: Option<
                Box<dyn Fn(&Search) -> HashMap<Style, String>>,
            > = Some(Box::new(|search| {
                // create styles
                let mut styles = HashMap::new();
                styles.insert((1, 1), ("#1abc9c", "s"));
                styles.insert((2, 1), ("#218c74", "s"));
                styles.insert((2, 2), ("#218c74", "+"));
                styles.insert((3, 1), ("#bdc3c7", "s"));
                styles.insert((3, 2), ("#bdc3c7", "+"));
                styles.insert((4, 1), ("#ffa726", "s"));
                styles.insert((4, 2), ("#ffa726", "+"));
                styles.insert((5, 1), ("#227093", "s"));
                styles.insert((5, 2), ("#227093", "+"));

                // get shards config of this search
                let shards_per_command = search.shards_per_command.unwrap();
                let ShardGen::Random { shard_count } =
                    search.shard_gen.unwrap();

                // find color and marker for this search
                let (color, marker) = if let Some(entry) =
                    styles.get(&(shard_count, shards_per_command))
                {
                    entry
                } else {
                    panic!(
                        "unsupported shards config pair: {:?}",
                        (shard_count, shards_per_command)
                    );
                };

                // set all styles for this search
                let mut style = HashMap::new();
                style.insert(
                    Style::Label,
                    format!("({}, {})", shard_count, shards_per_command),
                );
                style.insert(Style::Color, color.to_string());
                style.insert(Style::Marker, marker.to_string());
                style
            }));
            fantoch_plot::throughput_latency_plot(
                searches,
                style_fun,
                n,
                clients_per_region.clone(),
                latency_metric,
                PLOT_DIR,
                &path,
                &db,
            )?;
        }

        for (shard_count, shards_per_command) in shard_combinations.clone() {
            let shard_gen = ShardGen::Random { shard_count };

            // generate throughput-latency plot
            for latency_metric in vec![
                LatencyMetric::Average,
                LatencyMetric::Percentile(0.99),
                LatencyMetric::Percentile(0.999),
            ] {
                let path = format!(
                    "throughput_latency_n{}_ts{}_s{}_{}{}.pdf",
                    n,
                    shard_count,
                    shards_per_command,
                    key_gen,
                    latency_metric.to_file_suffix(),
                );
                // create searches
                let searches = protocol_combinations(n, protocols.clone())
                    .into_iter()
                    .map(|(protocol, f)| {
                        let mut search = Search::new(n, f, protocol);
                        search
                            .shards_per_command(shards_per_command)
                            .shard_gen(shard_gen)
                            .keys_per_shard(keys_per_shard)
                            .key_gen(key_gen)
                            .payload_size(payload_size);
                        search
                    })
                    .collect();
                let style_fun = None;
                fantoch_plot::throughput_latency_plot(
                    searches,
                    style_fun,
                    n,
                    clients_per_region.clone(),
                    latency_metric,
                    PLOT_DIR,
                    &path,
                    &db,
                )?;
            }

            // generate dstat, latency and cdf plots
            for clients_per_region in clients_per_region.clone() {
                println!(
                    "n = {} | ts = {} | s = {} | {} | c = {}",
                    n,
                    shard_count,
                    shards_per_command,
                    key_gen,
                    clients_per_region,
                );

                // create searches
                let searches: Vec<_> =
                    protocol_combinations(n, protocols.clone())
                        .into_iter()
                        .map(move |(protocol, f)| {
                            let mut search = Search::new(n, f, protocol);
                            search
                                .clients_per_region(clients_per_region)
                                .shards_per_command(shards_per_command)
                                .shard_gen(shard_gen)
                                .keys_per_shard(keys_per_shard)
                                .key_gen(key_gen)
                                .payload_size(payload_size);
                            search
                        })
                        .collect();

                // generate dstat table
                for metrics_type in dstat_combinations(shard_count, n) {
                    let path = format!(
                        "dstat_n{}_ts{}_s{}_c{}_{}_{}.pdf",
                        n,
                        shard_count,
                        shards_per_command,
                        clients_per_region,
                        key_gen,
                        metrics_type.name(),
                    );
                    fantoch_plot::dstat_table(
                        searches.clone(),
                        metrics_type,
                        PLOT_DIR,
                        &path,
                        &db,
                    )?;
                }

                // generate process metrics table
                for metrics_type in process_metrics_combinations(shard_count, n)
                {
                    let path = format!(
                        "metrics_n{}_ts{}_s{}_c{}_{}_{}.pdf",
                        n,
                        shard_count,
                        shards_per_command,
                        clients_per_region,
                        key_gen,
                        metrics_type.name(),
                    );
                    fantoch_plot::process_metrics_table(
                        searches.clone(),
                        metrics_type,
                        PLOT_DIR,
                        &path,
                        &db,
                    )?;
                }

                // generate latency plot
                let mut shown = false;
                for error_bar in vec![
                    ErrorBar::Without,
                    ErrorBar::With(0.99),
                    ErrorBar::With(0.999),
                ] {
                    let path = format!(
                        "latency_n{}_ts{}_s{}_{}_c{}{}.pdf",
                        n,
                        shard_count,
                        shards_per_command,
                        key_gen,
                        clients_per_region,
                        error_bar.to_file_suffix(),
                    );
                    let style_fun = None;
                    let results = fantoch_plot::latency_plot(
                        searches.clone(),
                        style_fun,
                        n,
                        error_bar,
                        PLOT_DIR,
                        &path,
                        &db,
                        fmt_exp_data,
                    )?;

                    if !shown {
                        // only show results once
                        for (search, histogram_fmt) in results {
                            println!(
                                "{:<7} f = {} | {}",
                                PlotFmt::protocol_name(search.protocol),
                                search.f,
                                histogram_fmt,
                            );
                        }
                        shown = true;
                    }
                }

                // generate cdf plot
                let path = format!(
                    "cdf_n{}_ts{}_s{}_{}_c{}.pdf",
                    n,
                    shard_count,
                    shards_per_command,
                    key_gen,
                    clients_per_region
                );
                let style_fun = None;
                fantoch_plot::cdf_plot(
                    searches.clone(),
                    style_fun,
                    PLOT_DIR,
                    &path,
                    &db,
                )?;
            }
        }
    }

    Ok(())
}

#[allow(dead_code)]
fn multi_key() -> Result<(), Report> {
    // fixed parameters
    let shard_count = 1;
    let n = 5;
    let zipf_key_count = 1_000_000;
    // let key_gen = KeyGen::ConflictRate { conflict_rate: 10 };
    let payload_size = 0;
    let protocols = vec![
        Protocol::NewtAtomic,
        Protocol::NewtLocked,
        // Protocol::NewtFineLocked,
    ];

    // load results
    let db = ResultsDB::load(RESULTS_DIR).wrap_err("load results")?;

    let clients_per_region = vec![256, 1024, 1024 * 4, 1024 * 8, 1024 * 16];

    for keys_per_shard in vec![8, 64] {
        for zipf_coefficient in vec![1.0] {
            // create key generator
            let key_gen = KeyGen::Zipf {
                coefficient: zipf_coefficient,
                key_count: zipf_key_count,
            };

            // generate throughput-latency plot
            for latency_metric in vec![
                LatencyMetric::Average,
                LatencyMetric::Percentile(0.99),
                LatencyMetric::Percentile(0.999),
            ] {
                let path = format!(
                    "throughput_latency_n{}_k{}_{}{}.pdf",
                    n,
                    keys_per_shard,
                    key_gen,
                    latency_metric.to_file_suffix(),
                );
                // create searches
                let searches = protocol_combinations(n, protocols.clone())
                    .into_iter()
                    .map(|(protocol, f)| {
                        let mut search = Search::new(n, f, protocol);
                        search
                            .keys_per_shard(keys_per_shard)
                            .key_gen(key_gen)
                            .payload_size(payload_size);
                        search
                    })
                    .collect();
                let style_fun = None;
                fantoch_plot::throughput_latency_plot(
                    searches,
                    style_fun,
                    n,
                    clients_per_region.clone(),
                    latency_metric,
                    PLOT_DIR,
                    &path,
                    &db,
                )?;
            }

            // generate dstat, latency and cdf plots
            for clients_per_region in clients_per_region.clone() {
                println!(
                    "n = {} | k = {} | {} | c = {}",
                    n, keys_per_shard, key_gen, clients_per_region,
                );

                // create searches
                let searches: Vec<_> =
                    protocol_combinations(n, protocols.clone())
                        .into_iter()
                        .map(move |(protocol, f)| {
                            let mut search = Search::new(n, f, protocol);
                            search
                                .clients_per_region(clients_per_region)
                                .key_gen(key_gen)
                                .keys_per_shard(keys_per_shard)
                                .payload_size(payload_size);
                            search
                        })
                        .collect();

                // generate dstat table
                for metrics_type in dstat_combinations(shard_count, n) {
                    let path = format!(
                        "dstat_n{}_k{}_c{}_{}_{}.pdf",
                        n,
                        keys_per_shard,
                        clients_per_region,
                        key_gen,
                        metrics_type.name(),
                    );
                    fantoch_plot::dstat_table(
                        searches.clone(),
                        metrics_type,
                        PLOT_DIR,
                        &path,
                        &db,
                    )?;
                }

                // generate process metrics table
                for metrics_type in process_metrics_combinations(shard_count, n)
                {
                    let path = format!(
                        "metrics_n{}_k{}_c{}_{}_{}.pdf",
                        n,
                        keys_per_shard,
                        clients_per_region,
                        key_gen,
                        metrics_type.name(),
                    );
                    fantoch_plot::process_metrics_table(
                        searches.clone(),
                        metrics_type,
                        PLOT_DIR,
                        &path,
                        &db,
                    )?;
                }

                // generate latency plot
                let mut shown = false;
                for error_bar in vec![
                    ErrorBar::Without,
                    ErrorBar::With(0.99),
                    ErrorBar::With(0.999),
                ] {
                    let path = format!(
                        "latency_n{}_k{}_{}_c{}{}.pdf",
                        n,
                        keys_per_shard,
                        key_gen,
                        clients_per_region,
                        error_bar.to_file_suffix()
                    );
                    let style_fun = None;
                    let results = fantoch_plot::latency_plot(
                        searches.clone(),
                        style_fun,
                        n,
                        error_bar,
                        PLOT_DIR,
                        &path,
                        &db,
                        fmt_exp_data,
                    )?;

                    if !shown {
                        // only show results once
                        for (search, histogram_fmt) in results {
                            println!(
                                "{:<7} f = {} | {}",
                                PlotFmt::protocol_name(search.protocol),
                                search.f,
                                histogram_fmt,
                            );
                        }
                        shown = true;
                    }
                }

                // generate cdf plot
                let path = format!(
                    "cdf_n{}_k{}_{}_c{}.pdf",
                    n, keys_per_shard, key_gen, clients_per_region
                );
                let style_fun = None;
                fantoch_plot::cdf_plot(
                    searches.clone(),
                    style_fun,
                    PLOT_DIR,
                    &path,
                    &db,
                )?;

                if n > 3 {
                    // generate cdf plot with subplots
                    let path = format!(
                        "cdf_one_per_f_n{}_k{}_{}_c{}.pdf",
                        n, keys_per_shard, key_gen, clients_per_region,
                    );
                    let style_fun = None;
                    fantoch_plot::cdf_plot_per_f(
                        searches.clone(),
                        style_fun,
                        PLOT_DIR,
                        &path,
                        &db,
                    )?;
                }
            }
        }
    }

    Ok(())
}

#[allow(dead_code)]
fn single_key() -> Result<(), Report> {
    // fixed parameters
    let key_gen = KeyGen::ConflictRate { conflict_rate: 10 };
    let payload_size = 4096;
    let protocols = vec![
        Protocol::NewtAtomic,
        Protocol::AtlasLocked,
        Protocol::FPaxos,
    ];

    // load results
    let db = ResultsDB::load(RESULTS_DIR).wrap_err("load results")?;

    for n in vec![3, 5] {
        // generate throughput-latency plot
        let clients_per_region = vec![
            32,
            512,
            1024,
            1024 * 2,
            1024 * 4,
            1024 * 8,
            1024 * 16,
            1024 * 32,
        ];

        for latency_metric in vec![
            LatencyMetric::Average,
            LatencyMetric::Percentile(0.99),
            LatencyMetric::Percentile(0.999),
        ] {
            let path = format!(
                "throughput_latency_n{}{}.pdf",
                n,
                latency_metric.to_file_suffix()
            );
            // create searches
            let searches = protocol_combinations(n, protocols.clone())
                .into_iter()
                .map(|(protocol, f)| {
                    let mut search = Search::new(n, f, protocol);
                    search.key_gen(key_gen).payload_size(payload_size);
                    search
                })
                .collect();
            let style_fun = None;
            fantoch_plot::throughput_latency_plot(
                searches,
                style_fun,
                n,
                clients_per_region.clone(),
                latency_metric,
                PLOT_DIR,
                &path,
                &db,
            )?;
        }

        // generate latency plots
        for clients_per_region in vec![
            4,
            8,
            16,
            32,
            64,
            128,
            256,
            512,
            1024,
            1024 * 2,
            1024 * 4,
            1024 * 8,
            1024 * 16,
            1024 * 32,
        ] {
            println!("n = {} | c = {}", n, clients_per_region);

            // create searches
            let searches: Vec<_> = protocol_combinations(n, protocols.clone())
                .into_iter()
                .map(|(protocol, f)| {
                    let mut search = Search::new(n, f, protocol);
                    search
                        .clients_per_region(clients_per_region)
                        .key_gen(key_gen)
                        .payload_size(payload_size);
                    search
                })
                .collect();

            // generate latency plot
            let mut shown = false;
            for error_bar in vec![
                ErrorBar::Without,
                ErrorBar::With(0.99),
                ErrorBar::With(0.999),
            ] {
                let path = format!(
                    "latency_n{}_c{}{}.pdf",
                    n,
                    clients_per_region,
                    error_bar.to_file_suffix()
                );
                let style_fun = None;
                let results = fantoch_plot::latency_plot(
                    searches.clone(),
                    style_fun,
                    n,
                    error_bar,
                    PLOT_DIR,
                    &path,
                    &db,
                    fmt_exp_data,
                )?;

                if !shown {
                    // only show results once
                    for (search, histogram_fmt) in results {
                        println!(
                            "{:<7} f = {} | {}",
                            PlotFmt::protocol_name(search.protocol),
                            search.f,
                            histogram_fmt,
                        );
                    }
                    shown = true;
                }
            }

            // generate cdf plot
            let path = format!("cdf_n{}_c{}.pdf", n, clients_per_region);
            let style_fun = None;
            fantoch_plot::cdf_plot(
                searches.clone(),
                style_fun,
                PLOT_DIR,
                &path,
                &db,
            )?;

            if n > 3 {
                // generate cdf plot with subplots
                let path =
                    format!("cdf_one_per_f_n{}_c{}.pdf", n, clients_per_region);
                let style_fun = None;
                fantoch_plot::cdf_plot_per_f(
                    searches.clone(),
                    style_fun,
                    PLOT_DIR,
                    &path,
                    &db,
                )?;
            }
        }
    }

    Ok(())
}

#[allow(dead_code)]
fn show_distance_matrix() {
    // show distance matrix
    let planet = Planet::from("../latency_aws/");
    let regions = vec![
        Region::new("eu-west-1"),
        Region::new("us-west-1"),
        Region::new("ap-southeast-1"),
        Region::new("ca-central-1"),
        Region::new("sa-east-1"),
    ];
    println!("{}", planet.distance_matrix(regions).unwrap());
}

fn protocol_combinations(
    n: usize,
    mut protocols: Vec<Protocol>,
) -> Vec<(Protocol, usize)> {
    protocols.sort_by_key(|&protocol| PlotFmt::protocol_name(protocol));
    let max_f = match n {
        3 => 1,
        5 => 2,
        _ => panic!("combinations: unsupported n = {}", n),
    };

    // compute all protocol combinations
    let mut combinations = Vec::new();
    for protocol in protocols {
        for f in 1..=max_f {
            combinations.push((protocol, f));
        }
    }

    combinations
}

fn dstat_combinations(shard_count: usize, n: usize) -> Vec<MetricsType> {
    let global_metrics =
        vec![MetricsType::ProcessGlobal, MetricsType::ClientGlobal];
    fantoch::util::all_process_ids(shard_count, n)
        .map(|(process_id, _)| MetricsType::Process(process_id))
        .chain(global_metrics)
        .collect()
}

fn process_metrics_combinations(
    _shard_count: usize,
    _n: usize,
) -> Vec<MetricsType> {
    vec![MetricsType::ProcessGlobal]
}

fn fmt_exp_data(exp_data: &ExperimentData) -> String {
    format!("{:?}", exp_data.global_client_latency)
}
